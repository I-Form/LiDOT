function [StressStrain,AnalysisTime,Energies]=ExplicitBeamCompression(Geometry,FEA_Opts)
% Wites ABAQUS Explicit input file and runs job for compression of beam element lattice structure. 
% INPUTS
% Geometry - output of GenerateLattice function
% FEA_Opts - analysis options, see below or OptRun for details.
%
% ---- DEMO ---- 
% run with empty input strtuctures for unit cell demo/default settings
% e.g, run "ExplicitBeamCompression(GenerateLattice(struct),struct)"
% 

Plots=0;
abaqusPath='abq2019'; %'/usr/bin/abaqus'; %Abaqus excute command or path
%% DEFAULT Analysis Options
%abaqusInpFileNamePart= ['opt_' num2str(Taper(2)*10) ];   % Defining Abaqus file names
Opts.FileName= 'OptRun';   % Defining Abaqus file names
Opts.appliedStrain=-0.75;   %Applied strain to top plate (in Y direction)

% Step Settings 
Opts.Time=1;    %Step time length
Opts.MassScalingOn=1;
Opts.MSIncSize=1e-5;   %Mass scaling - defined stable increment size
Opts.Num_intervals=200;   %numbr of output intervals
% Contact and BCs
Opts.StrutContact=1;          %Strut contact on (1) / off (0) / 2 defining surfaces - not needed for explicit
Opts.BCsetting=1;           %1 is x and y symmetry, 2 is laterally constrained top and bottom,3 just bottom
Opts.FrictionCoeff=0;
%% DEFAULT Material Parameters
Opts.Material.PlasticOn= 1;   %0 for off, 1 for on
Opts.Material.DamageOn=0;

% 17-4 PH (B) No Heat treatment - Data Sheet
Opts.Material.Name='Datasheet 174PH';
Opts.Material.Elastic=[200000 0.3];
Opts.Material.Plastic=[620 0; 1100 0.16];
Opts.Material.Density=7.8e-9;


%% Change parameters accoring to "Options Input"
Fields=fieldnames(FEA_Opts);
for i=1:numel(Fields)
    Opts.(Fields{i})=FEA_Opts.(Fields{i});
end

%% Define variables for lattice Geometry
V = Geometry.V;
E = Geometry.E;
element_normals = Geometry.element_normals;
S_E = Geometry.S_E;
Diameters = Geometry.Diameters;
clearence = Geometry.clearence;

% Define some variables based on inputs
el_per_strut=Geometry.lattice_params.el_per_strut;  
elementtype=size(E,2) - 2;      
ConExcl=round((el_per_strut/4));           %Number of elements excluded from contact at nodes


%% Path names Control parameters
savePath =fullfile(fileparts(mfilename('fullpath')),'\abq_out');
%savePath=fullfile(defaultFolder,'data','temp');

abaqusInpFileName=fullfile(savePath,[Opts.FileName,'.inp']); %INP file name

%% Top/Bottom Surfaces, and Corner Nodes for BCs
% % Find top/bottom and sides
Vind=1:size(V,1);

VBottom=Vind(V(:,3)==min(V(:,3)));
EBotttom= E(:,1)==VBottom | E(:,2)==VBottom | E(:,3)==VBottom;
EBotttom=logical(sum(EBotttom,2));

VTop=Vind(V(:,3)==max(V(:,3))); 
ETop= E(:,1)==VTop | E(:,2)==VTop | E(:,3)==VTop;
ETop=logical(sum(ETop,2));

logicXFace=V(:,1)==min(V(:,1)); 
logicYFace=V(:,2)==min(V(:,2)); 


%X and Z faces
bcXFace=find(logicXFace); 
bcYFace=find(logicYFace);

%% Get Size of Part
GeomSize(1,:) = max(V,[],1); GeomSize(2,:) = min(V,[],1); 
GeomSize(3,:)=abs(diff(GeomSize,[],1));
BotPHeight = GeomSize(2,3) - clearence(1) ; 
TopPHeight = GeomSize(1,3) + clearence(2) ;
% TopPHeight=GeomSize(1,3)+0.5*(max(Diameters(ETop)));  %Set bottom plate to minumum Y
% BotPHeight=GeomSize(2,3)-0.5*(max(Diameters(EBotttom)));  %Set bottom plate to max Y
displacementMagnitude=GeomSize(3,3)*Opts.appliedStrain; 

% Adds normal nodes (used for beam section definition) to node array
V = [V; element_normals];  

E_Vectors=V(E(:,end),:) - V(E(:,1),:);  %gets vector of direction of each element
%E_midpoints= (V(E(:,end),:) + V(E(:,1),:))./2;  %gets midpoint of each element
E_Lengths=sqrt( (E_Vectors(:,1)).^2 + (E_Vectors(:,2)).^2 + (E_Vectors(:,3)).^2);   %Get length of each element

%% Define Element & Node IDs
elementIds=(1:1:size(E,1))';
nodeIds=(1:1:size(V,1))';

material_IDs = unique(Geometry.material_ID);

%% Defining the abaqus input structure
% See also |abaqusStructTemplate| and |abaqusStruct2inp| and the abaqus user
% manual

%%--> Heading
abaqus_spec.Heading.COMMENT{1}='Job name: Lattice Compression';
abaqus_spec.Heading.COMMENT{2}='Generated by: GIBBON';

%%--> Preprint
abaqus_spec.Preprint.ATTR.echo='NO';
abaqus_spec.Preprint.ATTR.model='NO';
abaqus_spec.Preprint.ATTR.history='NO';
abaqus_spec.Preprint.ATTR.contact='YES';

%--> Part

% Node
abaqus_spec.Part{1}.COMMENT='This section defines the part geometry in terms of nodes and elements';
abaqus_spec.Part{1}.ATTR.name='Cube';
abaqus_spec.Part{1}.Node={nodeIds,V};


if elementtype==2   %Quadratic Elements
    abaqus_spec.Part{1}.Element{1}.ATTR.type='B32';
elseif elementtype==1   %Linear Elements
    abaqus_spec.Part{1}.Element{1}.ATTR.type='B31';
end
abaqus_spec.Part{1}.Element{1}.VAL={elementIds(:),E};

% Element sets 
% All Elements
abaqus_spec.Part{1}.Elset{1}.ATTR.elset='AllEl'; 
abaqus_spec.Part{1}.Elset{1}.VAL=elementIds';

% Elements at lattice nodes (to stiffen nodes)
NodeEls=reshape( S_E(:,[2 end-1]) , numel(S_E(:,[2 end-1])),1);
abaqus_spec.Part{1}.Elset{2}.ATTR.elset='NodeEL';
abaqus_spec.Part{1}.Elset{2}.VAL=NodeEls' ;

% Set & Section Definitions - For each group of unique diameter & material
set_count = 0;
for i = material_IDs'
    mat_i_ID = find(Geometry.material_ID == i);
    mat_i_dia=round(Diameters(mat_i_ID),6);
    [UniqueDiams,~,u_ID]=unique(mat_i_dia,'stable');
    num_dia = numel(UniqueDiams);

    for j = 1:num_dia
        %diameter_group = find(ub == j);
        diameter_group = mat_i_ID(u_ID == j);
        abaqus_spec.Part{1}.Elset{2+ set_count + j}.ATTR.elset=['Mat_' num2str(i) 'D_' num2str(j)];
        abaqus_spec.Part{1}.Elset{2+ set_count + j}.VAL=diameter_group';

        abaqus_spec.Part{1}.Beam_section{set_count + j}.ATTR.elset=['Mat_' num2str(i) 'D_' num2str(j)];
        abaqus_spec.Part{1}.Beam_section{set_count + j}.ATTR.material=Opts.Material(i).Name;
        abaqus_spec.Part{1}.Beam_section{set_count + j}.ATTR.temperature='GRADIENTS';
        abaqus_spec.Part{1}.Beam_section{set_count + j}.ATTR.section='CIRC';
        abaqus_spec.Part{1}.Beam_section{set_count + j}.VAL{1,1}={UniqueDiams(j)/2};
           
    end
    
    set_count = set_count + j;

end

if size(S_E,2) >= 4
    NotNodeEls=reshape( S_E(:,3:end-2) , numel(S_E(:,3:end-2)),1);
    abaqus_spec.Part{1}.Elset{2 + set_count + 1}.ATTR.elset='NotNodeEL';
    abaqus_spec.Part{1}.Elset{2 + set_count + 1}.VAL=NotNodeEls' ;
end

%Surfaces - rigid plates
abaqus_spec.Part{2}.COMMENT='This section defines the part geometry in terms of nodes and elements';
abaqus_spec.Part{2}.ATTR.name='rigid_plate';
PlateRefNode=[0 0 0];
abaqus_spec.Part{2}.Node={1,PlateRefNode};

abaqus_spec.Part{2}.surface.ATTR.type='cylinder';
abaqus_spec.Part{2}.surface.ATTR.name='rigid_plate';
abaqus_spec.Part{2}.surface.VAL{1,1}={{'START'}, [2*GeomSize(3,1) 0]};
abaqus_spec.Part{2}.surface.VAL{2,1}={{'LINE'},[-(2*GeomSize(3,1)) 0] };

%Rigid Body
abaqus_spec.Part{2}.rigid_body.ATTR.analytical_surface='rigid_plate';
abaqus_spec.Part{2}.rigid_body.ATTR.ref_node=1;

%%--> Assembly
abaqus_spec.Assembly.ATTR.name='Assembly-1';
abaqus_spec.Assembly.Instance{1}.ATTR.name='Cube-assembly';
abaqus_spec.Assembly.Instance{1}.ATTR.part='Cube';

abaqus_spec.Assembly.Instance{2}.ATTR.name='rigid_plate_1';
abaqus_spec.Assembly.Instance{2}.ATTR.part='rigid_plate';
abaqus_spec.Assembly.Instance{2}.VAL{1,1}={[ 0 0 BotPHeight]};
abaqus_spec.Assembly.Instance{2}.VAL{2,1}={[ 0 0 BotPHeight 1 0 BotPHeight -90]};

abaqus_spec.Assembly.Instance{3}.ATTR.name='rigid_plate_2';
abaqus_spec.Assembly.Instance{3}.ATTR.part='rigid_plate';
abaqus_spec.Assembly.Instance{3}.VAL{1,1}={[ 0 0 TopPHeight]};
abaqus_spec.Assembly.Instance{3}.VAL{2,1}={[ 0 0 TopPHeight 1 0 TopPHeight 90]};


abaqus_spec.Assembly.Nset{1}.ATTR.nset='Top';
abaqus_spec.Assembly.Nset{1}.ATTR.instance='rigid_plate_2';
abaqus_spec.Assembly.Nset{1}.VAL=1;

abaqus_spec.Assembly.Nset{2}.ATTR.nset='Bottom';
abaqus_spec.Assembly.Nset{2}.ATTR.instance='rigid_plate_1';
abaqus_spec.Assembly.Nset{2}.VAL=1;

abaqus_spec.Assembly.Nset{3}.ATTR.nset='all';
abaqus_spec.Assembly.Nset{3}.ATTR.instance='Cube-assembly';
abaqus_spec.Assembly.Nset{3}.VAL=1:1:size(V,1);

abaqus_spec.Assembly.Nset{4}.ATTR.nset='XFace';
abaqus_spec.Assembly.Nset{4}.ATTR.instance='Cube-assembly';
abaqus_spec.Assembly.Nset{4}.VAL=bcXFace';

abaqus_spec.Assembly.Nset{5}.ATTR.nset='YFace';
abaqus_spec.Assembly.Nset{5}.ATTR.instance='Cube-assembly';
abaqus_spec.Assembly.Nset{5}.VAL=bcYFace';

abaqus_spec.Assembly.Nset{6}.ATTR.nset='TopFace';
abaqus_spec.Assembly.Nset{6}.ATTR.instance='Cube-assembly';
abaqus_spec.Assembly.Nset{6}.VAL=VTop;

abaqus_spec.Assembly.Nset{7}.ATTR.nset='BotFace';
abaqus_spec.Assembly.Nset{7}.ATTR.instance='Cube-assembly';
abaqus_spec.Assembly.Nset{7}.VAL=VBottom;

abaqus_spec.Assembly.Elset{1}.ATTR.elset='AllElA';
abaqus_spec.Assembly.Elset{1}.ATTR.instance='Cube-assembly';
abaqus_spec.Assembly.Elset{1}.VAL=elementIds';

abaqus_spec.Assembly.Elset{2}.ATTR.elset='NodeElA';
abaqus_spec.Assembly.Elset{2}.ATTR.instance='Cube-assembly';
abaqus_spec.Assembly.Elset{2}.VAL=NodeEls';

% Elements at lattice nodes to exclude from contact - prevent unwanted
% % stran free adjustments from ABAQUS
% ContactExclusions=reshape( S_E(:,[1:ConExcl end-(ConExcl-1):end]) ,...
%                 numel(S_E(:,[1:ConExcl end-(ConExcl-1):end])),1);
% abaqus_spec.Assembly.Elset{3}.ATTR.elset='ContactExclusions';
% abaqus_spec.Assembly.Elset{3}.ATTR.instance='Cube-assembly';
% abaqus_spec.Assembly.Elset{3}.VAL=ContactExclusions;

% Displacement Amplitude
abaqus_spec.Amplitude.ATTR.name='Amp-1';
abaqus_spec.Amplitude.VAL=[ 0 0 Opts.Time 1];



%%--> Material
for i = 1:size(Opts.Material,2)
    abaqus_spec.Material{i}.ATTR.name=Opts.Material(i).Name;
    abaqus_spec.Material{i}.Elastic=Opts.Material(i).Elastic;
    abaqus_spec.Material{i}.Density=Opts.Material(i).Density;
    if Opts.Material(i).PlasticOn==1
        abaqus_spec.Material{i}.Plastic=Opts.Material(i).Plastic;
    end

    if Opts.Material(i).DamageOn==1   % Damage can be included
        abaqus_spec.Material{i}.DAMAGE_INITIATION.ATTR.Criterion='DUCTILE';
        %Fracture strain, stress triaxility and strain rate
        abaqus_spec.Material{i}.DAMAGE_INITIATION.VAL={Opts.Material(i).FractureStrain, 0.333, 0};  
        abaqus_spec.Material{i}.Damage_Evolution.ATTR.type='Displacement';
        abaqus_spec.Material{i}.Damage_Evolution.ATTR.Softening='Linear';
        abaqus_spec.Material{i}.Damage_Evolution.VAL=Opts.Material(i).DispAtFailure;

        %%--> Section Controls 
        abaqus_spec.Section_Controls.ATTR.name='EC-1';
        abaqus_spec.Section_Controls.ATTR.ELEMENT_DELETION='YES';
        abaqus_spec.Section_Controls.ATTR.MAX_DEGRADATION=Opts.MaxDeg;
        abaqus_spec.Section_Controls.VAL=[ 1 1 1];
    end
end




%%--> Contact
%Defining contact properties
abaqus_spec.Surface_Interaction.ATTR.name='IntProp-1';
abaqus_spec.Surface_Interaction.VAL=1;
abaqus_spec.Surface_Interaction.Friction.VAL=Opts.FrictionCoeff;
abaqus_spec.Surface_Interaction.Time_Points.ATTR.NAME='Start';
abaqus_spec.Surface_Interaction.Time_Points.VAL=0;


% Contact between plates and struts, %% Contact exclusions Surface
% abaqus_spec.Assembly.surface{1}.ATTR.type='ELEMENT';
% abaqus_spec.Assembly.surface{1}.ATTR.name='NoCONTACTSurf';
% abaqus_spec.Assembly.surface{1}.VAL='ContactExclusions';

abaqus_spec.Surface_Interaction.Contact.ATTR.op='NEW';
abaqus_spec.Surface_Interaction.Contact_Inclusions.ATTR.ALL_EXTERIOR='';
abaqus_spec.Surface_Interaction.Contact_Property_Assignment.VAL={'' ,'','IntProp-1'};

% abaqus_spec.Surface_Interaction.Contact_Exclusions='';
% abaqus_spec.Surface_Interaction.Contact_Exclusions.VAL='NoCONTACTSurf';  

% 
% %%--> Boudnary Conditions for initial step
% Fully Constrain bottom plate
abaqus_spec.Surface_Interaction.Boundary{1}.VAL{1,1}={'Bottom' , [1 6]};
% Constrain top plate in all DOF except displacement in Z
abaqus_spec.Surface_Interaction.Boundary{1}.VAL{2,1}={'Top' , 1};
abaqus_spec.Surface_Interaction.Boundary{1}.VAL{3,1}={'Top' , 2};
abaqus_spec.Surface_Interaction.Boundary{1}.VAL{4,1}={'Top' , [4 6]};
if Opts.BCsetting == 1  % Symmetry
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{5,1}={'XFace' , 1};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{6,1}={'XFace' , [5 6]};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{7,1}={'YFace' , 2};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{8,1}={'YFace' , 4};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{9,1}={'YFace' , 6};
elseif Opts.BCsetting == 0   %Prevent rigid body movements
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{5,1}={'XFace' , 1};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{6,1}={'YFace' , 2};
 elseif Opts.BCsetting == 2   
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{5,1}={'BotFace' ,[1 2]};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{6,1}={'TopFace' ,[1 2]}; 
elseif Opts.BCsetting == 3   %Constrained lateral displacement & rotation top and bottom
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{5,1}={'BotFace' ,[1 2]};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{6,1}={'BotFace' ,[4 6]};
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{7,1}={'TopFace' ,[1 2]}; 
    abaqus_spec.Surface_Interaction.Boundary{1}.VAL{8,1}={'TopFace' ,[4 6]}; 
end



%%--> Step
abaqus_spec.Step.ATTR.name='Step-1';
abaqus_spec.Step.ATTR.nlgeom='YES';
abaqus_spec.Step.Dynamic.ATTR.Explicit='';
abaqus_spec.Step.Dynamic.VAL={' ' , Opts.Time};
if  Opts.MassScalingOn==1
    abaqus_spec.Step.Dynamic.Fixed_Mass_Scaling.ATTR.dt=Opts.MSIncSize;
    abaqus_spec.Step.Dynamic.Fixed_Mass_Scaling.ATTR.type='below min';
    elseif  Opts.MassScalingOn==2
    abaqus_spec.Step.Dynamic.Variable_Mass_Scaling.ATTR.dt=Opts.MSIncSize;
    abaqus_spec.Step.Dynamic.Variable_Mass_Scaling.ATTR.type='below min';
    abaqus_spec.Step.Dynamic.Variable_Mass_Scaling.ATTR.Number_interval=Opts.MSIntervals;
    
end


% Boundary Conditions for step 1
abaqus_spec.Step.Boundary.ATTR.type='Displacement';
abaqus_spec.Step.Boundary.ATTR.amplitude='Amp-1';
abaqus_spec.Step.Boundary.VAL={'Top',[3 3],displacementMagnitude};


%Output
abaqus_spec.Step.Restart.ATTR.write='';
abaqus_spec.Step.Restart.ATTR.number_interval=20;
abaqus_spec.Step.Restart.ATTR.time_marks='NO';

abaqus_spec.Step.Output{1}.ATTR.field='';
abaqus_spec.Step.Output{1}.ATTR.number_interval=Opts.Num_intervals;
abaqus_spec.Step.Output{1}.ATTR.variable='PRESELECT';
abaqus_spec.Step.Output{2}.ATTR.history='';
abaqus_spec.Step.Output{2}.ATTR.variable='PRESELECT';
abaqus_spec.Step.Output{3}.ATTR.field='';
abaqus_spec.Step.Output{3}.ATTR.number_interval=Opts.Num_intervals;
abaqus_spec.Step.Output{3}.Element_Output.ATTR.Directions={'Yes'};
abaqus_spec.Step.Output{3}.Element_Output.VAL={'STATUS','EVOL','SDEG'};

%%
if ~exist(savePath, 'dir')
   mkdir(savePath)
end

abaqusStruct2inpBMcD(abaqus_spec,abaqusInpFileName);

%textView(abaqusInpFileName);

%% Run the job using Abaqus
tic

lockFileName=fullfile(savePath,[Opts.FileName,'.lck']);
if exist(lockFileName,'file')
    warning('Lockfile found and deleted')
    delete(lockFileName);
end

%%

oldPath=pwd; %Get current working directory
cd(savePath); %Set new working directory to match save patch

runFlag=system([abaqusPath,' inp=',abaqusInpFileName,' job=',Opts.FileName,' interactive ask_delete=OFF',' double']);

cd(oldPath); %Restore working directory


AnalysisTime=toc;

%% Import and visualize abaqus results
% Run pythin script to create a report contaning reaction force and energy data
addpath('abq_out')

if exist('abq_out/RFReport.rpt', 'file')==2
    delete('abq_out/RFReport.rpt')
end
if exist('abq_out/Energy.rpt', 'file')==2
    delete('abq_out/Energy.rpt')
end

system(['abaqus cae noGUI=ExplicitReport.py -- ' savePath [' \' Opts.FileName '.odb']]);
delete('abaqus.rpy');

% Import data reaction force data
RFdata = importdata('RFReport.rpt',' ',5) ;
[timeVec,i_unique,~] = unique(RFdata.data(:,1));
RF = RFdata.data(i_unique,2); 

% Calculate displacement from time and displacment magnitude
raw_displacement = (abs(displacementMagnitude)*timeVec)/Opts.Time ;

% Adjust data to remove first n rows with 0 reaction force
data_start_ind = find(RF ~= 0, 1, 'first') - 1;
adj_displacement = raw_displacement(data_start_ind : end) - raw_displacement(data_start_ind);
adj_RF = RF(data_start_ind : end);

% get strain from displacement magnitude and distance between plates
% account for distance removed in previous step
OvrStrain= adj_displacement/((TopPHeight - BotPHeight) - raw_displacement(data_start_ind)) ; 

% Get stress data from initial model dimensions and reaction force
OvrStress = abs(adj_RF)/(GeomSize(3,1)*GeomSize(3,2));  

% Import energy data
Energydata = importdata('Energy.rpt') ;
Energies=Energydata.data;
Energies=[Energies (Energies(:,3)./Energies(:,2))];


%% Plot
if Plots ==1
    %% Plot Overall Stress/strain Curve
    figure
    plot(OvrStrain,OvrStress,'-*')
    ylabel('\sigma Compressive Stress (MPa)')
    xlabel('\epsilon Strain')
end

StressStrain=[OvrStrain OvrStress];

end

%%
% Lattice Inverse Design & Optimisation Tool 
% 06/12/2023 - Brian McDonnell - University of Galway
% GNU AFFERO GENERAL PUBLIC LICENSE - See LICENSE file details